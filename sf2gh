#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright © 2015 Michal Čihař <michal@cihar.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
import argparse
import sys
import json
import os.path
import urllib2
import re
from xdg.BaseDirectory import save_config_path

SF_URL = 'https://sourceforge.net/p/{0}/{1}/{2}/'
BODY_TEMPLATE = u'''{body}

---
* **Original URL**: <{url}>
* **Original author**: {author}
{attachments}
'''
POST_TEMPLATE = u'''{body}

---
* **Original author**: {author}
{attachments}
'''
LABEL_MAP = {
    'Bugs': 'bug',
    'Feature Requests': 'enhancement',
    'Patches': 'patch',
    'Translations': 'translation',
    'Support Requests': 'question',
}
TILDES = re.compile('^~~~+$')
USER_MAP = {
    'nijel': 'nijel',
    'madhuracj': 'madhuracj',
    'lem9': 'lem9',
    'atul5': 'zixtor',
    'ibennetch': 'ibennetch',
    'tithugues': 'Tithugues',
    'chirayu45': 'D-storm',
    'smita786': 'smita786',
}


class StatusStorage(object):
    def __init__(self):
        self.path = os.path.join(
            save_config_path('sf2gh'),
            'status.json'
        )
        self.data = {}

    def load(self):
        if os.path.exists(self.path):
            with open(self.path, 'r') as handle:
                self.data = json.load(handle)
        if 'tickets' not in self.data:
            self.data['tickets'] = {}

    def save(self):
        with open(self.path, 'w') as handle:
            json.dump(self.data, handle, indent=2)

    def clean(self):
        self.data = {}
        self.save()


class GitHubImport(object):
    def __init__(self, args):
        self.status = StatusStorage()
        self.status.load()
        self.handle = args.import_handle
        self.token = args.token
        self.repo = args.repo
        self.verbose = args.verbose
        self.sf_project = args.sf_project
        self.mount_point = None
        self.tracker_label = None
        self.closed_states = None
        self.milestones = None

    def api(self, url, data=None):
        if data:
            data = json.dumps(data)
        if 'https://' not in url:
            url = 'https://api.github.com/repos/{0}/{1}'.format(
                self.repo, url
            )
        request = urllib2.Request(
            url,
            data,
            {
                'Authorization': 'token {0}'.format(self.token),
                'Accept': 'application/vnd.github.golden-comet-preview+json',
            }
        )
        handle = urllib2.urlopen(request)

        result = json.load(handle)

        if 'Link' in handle.headers:
            for item in handle.headers['Link'].split(','):
                url, rel = item.split(';')
                url = url.strip()
                rel = rel.strip()
                if rel == 'rel="next"':
                    result += self.api(url[1:-1])
        return result

    def create_milestone(self, title):
        data = {
            'title': title,
            'state': 'closed',
            'description': 'Imported from SourceForge.net',
        }
        response = self.api(
            'milestones',
            data
        )
        self.milestones[response['title']] = response['number']
        if self.verbose:
            print 'Created milestone {0}'.format(title)

    def format_time(self, timestamp):
        return '{0}Z'.format(timestamp.replace(' ', 'T'))

    def clean(self):
        self.status.clean()

    def check(self):
        self.status.save()

    def get_tracker_label(self, data):
        mount = data['tracker_config']['options']['mount_label']
        return LABEL_MAP[mount]

    def get_assignee(self, ticket):
        if ticket['assigned_to'] in USER_MAP:
            return USER_MAP[ticket['assigned_to']]
        return ''

    def process(self):
        data = json.load(self.handle)

        # Tracker mount point
        self.mount_point = data['tracker_config']['options']['mount_point']
        self.tracker_label = self.get_tracker_label(data)
        self.closed_states = data['closed_status_names'].split()

        self.milestones = {
            m['title']: m['number'] for m in
            self.api('milestones?state=all')
        }

        for ticket in data['tickets']:
            self.process_ticket(ticket)
            self.status.save()

    def process_ticket(self, ticket):
        url = SF_URL.format(
            self.sf_project, self.mount_point, ticket['ticket_num']
        )

        labels = [
            'SourceForge',
            self.tracker_label,
        ]

        if 'duplicate' in ticket['status']:
            labels.append('duplicate')
        elif 'invalid' in ticket['status']:
            labels.append('invalid')
        elif 'out-of-date' in ticket['status']:
            labels.append('invalid')
        elif 'works-for-me' in ticket['status']:
            labels.append('invalid')
        elif 'wont-fix' in ticket['status']:
            labels.append('wontfix')

        summary = ticket['summary']
        milestone = None
        if summary.startswith('(in ') or summary.startswith('(ok '):
            milestone, summary = summary.split(')', 1)
            # Remove prefix and possible suffix (eg. 2.11-dev, or 2.11.3-rc1)
            milestone = milestone[4:].split('-')[0].strip()
        summary = summary.strip()

        issue = {
            'title': summary,
            'body': BODY_TEMPLATE.format(
                url=url,
                body=self.process_body(ticket['description']),
                author=ticket['reported_by'],
                attachments=self.process_attachments(ticket),
            ),
            'created_at': self.format_time(ticket['created_date']),
            'closed': ticket['status'] in self.closed_states,
            'labels': labels,
            'assignee': self.get_assignee(ticket),
        }

        if milestone:
            if milestone not in self.milestones:
                self.create_milestone(milestone)
            issue['milestone'] = self.milestones[milestone]

        comments = [
            self.process_comment(comment)
            for comment in ticket['discussion_thread']['posts']
        ]

        request = {'issue': issue, 'comments': comments}

        if self.verbose:
            print json.dumps(request, indent=2)

        response = self.api('import/issues', request)
        assert response['status'] == 'pending'
        print json.dumps(response, indent=2)

        self.status.data['tickets'][url] = {
            'import_response': response,
        }

    def process_body(self, description):
        # SourceForge.net special markup
        description = description.replace(
            '\\*', '*'
        ).replace(
            '\\!', '!'
        ).replace(
            '\\_', '_'
        ).replace(
            '\\(', '('
        ).replace(
            '\\)', ')'
        )
        TILDES.sub('```', description)
        lines = description.splitlines()

        # Reformat initial state change texts
        for i, line in enumerate(lines):
            if line.startswith('- **'):
                lines[i] = u'* {0}'.format(line[1:])
            else:
                break

        return '\n'.join(lines)

    def process_comment(self, post):
        return {
            'created_at': self.format_time(post['timestamp']),
            'body': POST_TEMPLATE.format(
                body=self.process_body(post['text']),
                author=post['author'],
                attachments=self.process_attachments(post),
            ),
        }

    def process_attachments(self, post):
        result = []
        for attachment in post['attachments']:
            result.append(
                '* **Attachment**: <{0}>'.format(attachment['url'])
            )
        return '\n'.join(result)


def get_parser():
    parser = argparse.ArgumentParser(
        description='SourceForge.net to GitHub issue import',
    )

    # General parameters
    parser.add_argument(
        '--token',
        help=(
            'GitHub OAuth token, get it at ' +
            'https://github.com/settings/tokens'
        ),
        required=True,
    )
    parser.add_argument(
        '--repo',
        help='GitHub repository where to import',
        required=True
    )
    parser.add_argument(
        '--sf-project',
        help='Name of SourceForge.net project, eg. phpmyadmin',
        required=True
    )
    parser.add_argument(
        '--verbose',
        help='Verbose processing',
        action='store_true',
    )

    # Actions
    group = parser.add_mutually_exclusive_group(
        required=True
    )
    group.add_argument(
        '--import',
        help='SourceForge.net tracker backup json',
        type=argparse.FileType('r'),
        dest='import_handle'
    )
    group.add_argument(
        '--check',
        help='Check status of previous imports',
        action='store_true'
    )
    group.add_argument(
        '--clean',
        help='Clean local storage of previous imports',
        action='store_true'
    )

    return parser


def main():
    parser = get_parser()
    args = parser.parse_args(sys.argv[1:])
    importer = GitHubImport(args)
    if args.clean:
        importer.clean()
    elif args.check:
        importer.check()
    else:
        importer.process()


if __name__ == "__main__":
    main()
