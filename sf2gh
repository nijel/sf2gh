#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright © 2015 Michal Čihař <michal@cihar.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
import argparse
import sys
import json
import os.path
import urllib2
from xdg.BaseDirectory import save_config_path

SF_URL = 'https://sourceforge.net/p/{0}/{1}/{2}/'
BODY_TEMPLATE = u'''{body}

Original URL: {url}

Original author: {author}
'''
POST_TEMPLATE = u'''{body}

Original author: {author}
'''


class StatusStorage(object):
    def __init__(self):
        self.path = os.path.join(
            save_config_path('sf2gh'),
            'status.json'
        )
        self.data = {}

    def load(self):
        if os.path.exists(self.path):
            with open(self.path, 'r') as handle:
                self.data = json.load(handle)
        if 'tickets' not in self.data:
            self.data['tickets'] = {}

    def save(self):
        with open(self.path, 'w') as handle:
            json.dump(self.data, handle, indent=2)

    def clean(self):
        self.data = {}
        self.save()


class GitHubImport(object):
    def __init__(self, args):
        self.status = StatusStorage()
        self.status.load()
        self.handle = args.import_handle
        self.token = args.token
        self.repo = args.repo
        self.verbose = args.verbose
        self.sf_project = args.sf_project
        self.mount_point = None
        self.mount_label = None
        self.closed_states = None
        self.milestones = None

    def api(self, url, data=None):
        if data:
            data = json.dumps(data)
        if 'https://' not in url:
            url = 'https://api.github.com{0}'.format(url)
        request = urllib2.Request(
            url,
            data,
            {
                'Authorization': 'token {0}'.format(self.token),
                'Accept': 'application/vnd.github.golden-comet-preview+json',
            }
        )
        handle = urllib2.urlopen(request)
    
        result = json.load(handle)

        if 'Link' in handle.headers:
            for item in handle.headers['Link'].split(','):
                url, rel = item.split(';')
                url = url.strip()
                rel = rel.strip()
                if rel == 'rel="next"':
                    result += self.api(url[1:-1])
        return result

    def create_milestone(self, title):
        data = {
            'title': title,
            'state': 'closed',
            'description': 'Imported from SourceForge',
        }
        response = self.api(
            '/repos/{0}/milestones'.format(self.repo),
            data
        )
        self.milestones[response['title']] = response['number']
        if self.verbose:
            print 'Created milestone {0}'.format(title)

    def clean(self):
        self.status.clean()

    def check(self):
        self.status.save()

    def process(self):
        data = json.load(self.handle)

        # Tracker mount point
        self.mount_point = data['tracker_config']['options']['mount_point']
        self.mount_label = data['tracker_config']['options']['mount_label']
        self.closed_states = data['closed_status_names'].split()

        self.milestones = {
            m['title']: m['number'] for m in
            self.api('/repos/{0}/milestones?state=all'.format(self.repo))
        }

        for ticket in data['tickets']:
            self.process_ticket(ticket)

        self.status.save()

    def process_ticket(self, ticket):
        url = SF_URL.format(
            self.sf_project, self.mount_point, ticket['ticket_num']
        )

        labels = [
            'SourceForge',
            self.mount_label,
        ]

        summary = ticket['summary']
        milestone = None
        if summary.startswith('(in ') or summary.startswith('(ok '):
            milestone, summary = summary.split(')', 1)
            # Remove prefix and possible suffix (eg. 2.11-dev, or 2.11.3-rc1)
            milestone = milestone[4:].split('-')[0].strip()
        summary = summary.strip()

        issue = {
            'title': summary,
            'body': BODY_TEMPLATE.format(
                url=url, body=ticket['description'], author=ticket['reported_by']
            ),
            'created_at': ticket['created_date'],
            'closed': ticket['status'] in self.closed_states,
            'labels': labels,
            # TODO: assignee
        }

        if milestone:
            if milestone not in self.milestones:
                self.create_milestone(milestone)
            issue['milestone'] = self.milestones[milestone]

        if self.verbose:
            print json.dumps(issue, indent=2)

        self.status.data['tickets'][url] = {
        }


def get_parser():
    parser = argparse.ArgumentParser(
        description='SourceForge.net to GitHub issue import',
    )

    # General parameters
    parser.add_argument(
        '--token',
        help='GitHub OAuth token, get it at https://github.com/settings/tokens',
        required=True,
    )
    parser.add_argument(
        '--repo',
        help='GitHub repository where to import',
        required=True
    )
    parser.add_argument(
        '--sf-project',
        help='Name of SourceForge.net project, eg. phpmyadmin',
        required=True
    )
    parser.add_argument(
        '--verbose',
        help='Verbose processing',
        action='store_true',
    )

    # Actions
    group = parser.add_mutually_exclusive_group(
        required=True
    )
    group.add_argument(
        '--import',
        help='SourceForge.net tracker backup json',
        type=argparse.FileType('r'),
        dest='import_handle'
    )
    group.add_argument(
        '--check',
        help='Check status of previous imports',
        action='store_true'
    )
    group.add_argument(
        '--clean',
        help='Clean local storage of previous imports',
        action='store_true'
    )

    return parser

def main():
    parser = get_parser()
    args = parser.parse_args(sys.argv[1:])
    importer = GitHubImport(args)
    if args.clean:
        importer.clean()
    elif args.check:
        importer.check()
    else:
        importer.process()


if __name__ == "__main__":
    main()
